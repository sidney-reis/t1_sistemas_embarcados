<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>HellfireOS v2.0: drivers/noc/noc.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HellfireOS v2.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_14bc92f4b96c8519b376567118ac28b3.html">drivers</a></li><li class="navelem"><a class="el" href="dir_7bbcfdae35c079f6d51678b73c01fd83.html">noc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">noc.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acb44cf0de3a986b823c53d881bff9568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="noc_8c.html#acb44cf0de3a986b823c53d881bff9568">ni_init</a> (void)</td></tr>
<tr class="memdesc:acb44cf0de3a986b823c53d881bff9568"><td class="mdescLeft">&#160;</td><td class="mdescRight">NoC driver: initializes the network interface.  <a href="#acb44cf0de3a986b823c53d881bff9568"></a><br/></td></tr>
<tr class="memitem:a7ca8f6357767be7d8d8f31a1f68902a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="noc_8c.html#a7ca8f6357767be7d8d8f31a1f68902a1">ni_isr</a> (void *arg)</td></tr>
<tr class="memdesc:a7ca8f6357767be7d8d8f31a1f68902a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">NoC driver: network interface interrupt service routine.  <a href="#a7ca8f6357767be7d8d8f31a1f68902a1"></a><br/></td></tr>
<tr class="memitem:a73af25121fa7d699224d30913bb3cfa9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="noc_8c.html#a73af25121fa7d699224d30913bb3cfa9">hf_cpuid</a> (void)</td></tr>
<tr class="memdesc:a73af25121fa7d699224d30913bb3cfa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current cpu id number.  <a href="#a73af25121fa7d699224d30913bb3cfa9"></a><br/></td></tr>
<tr class="memitem:ac100d0cfa54da4cf1c8ffda0947a7509"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="noc_8c.html#ac100d0cfa54da4cf1c8ffda0947a7509">hf_ncores</a> (void)</td></tr>
<tr class="memdesc:ac100d0cfa54da4cf1c8ffda0947a7509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of processors in the system.  <a href="#ac100d0cfa54da4cf1c8ffda0947a7509"></a><br/></td></tr>
<tr class="memitem:a7cc950118783aff78ef381c30f411f31"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="noc_8c.html#a7cc950118783aff78ef381c30f411f31">hf_comm_create</a> (uint16_t id, uint16_t port, uint16_t packets)</td></tr>
<tr class="memdesc:a7cc950118783aff78ef381c30f411f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a communication queue for a task, using a port number as an alias.  <a href="#a7cc950118783aff78ef381c30f411f31"></a><br/></td></tr>
<tr class="memitem:a2ca5bce1d7d281b5ca1ee007b170143b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="noc_8c.html#a2ca5bce1d7d281b5ca1ee007b170143b">hf_comm_destroy</a> (uint16_t id)</td></tr>
<tr class="memdesc:a2ca5bce1d7d281b5ca1ee007b170143b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a communication queue, returning packets buffered on a task message queue to the shared pool of packets.  <a href="#a2ca5bce1d7d281b5ca1ee007b170143b"></a><br/></td></tr>
<tr class="memitem:a27bdcde2185022f68eece2e0ed1c20ec"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="noc_8c.html#a27bdcde2185022f68eece2e0ed1c20ec">hf_recv</a> (uint16_t *source_cpu, uint16_t *source_port, int8_t *buf, uint16_t *size, uint16_t channel)</td></tr>
<tr class="memdesc:a27bdcde2185022f68eece2e0ed1c20ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message from a task (blocking receive).  <a href="#a27bdcde2185022f68eece2e0ed1c20ec"></a><br/></td></tr>
<tr class="memitem:ae7c110f06bc1e123f03b2d52d8b6d70f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="noc_8c.html#ae7c110f06bc1e123f03b2d52d8b6d70f">hf_send</a> (uint16_t target_cpu, uint16_t target_port, int8_t *buf, uint16_t size, uint16_t channel)</td></tr>
<tr class="memdesc:ae7c110f06bc1e123f03b2d52d8b6d70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to a task (blocking send).  <a href="#ae7c110f06bc1e123f03b2d52d8b6d70f"></a><br/></td></tr>
<tr class="memitem:a264ff860d8ad312fea8d658b6c254f17"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="noc_8c.html#a264ff860d8ad312fea8d658b6c254f17">hf_recvack</a> (uint16_t *source_cpu, uint16_t *source_port, int8_t *buf, uint16_t *size, uint16_t channel)</td></tr>
<tr class="memdesc:a264ff860d8ad312fea8d658b6c254f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message from a task (blocking receive) with acknowledgement.  <a href="#a264ff860d8ad312fea8d658b6c254f17"></a><br/></td></tr>
<tr class="memitem:a288522d034824d53cf10c6f71bca41ea"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="noc_8c.html#a288522d034824d53cf10c6f71bca41ea">hf_sendack</a> (uint16_t target_cpu, uint16_t target_port, int8_t *buf, uint16_t size, uint16_t channel, uint32_t timeout)</td></tr>
<tr class="memdesc:a288522d034824d53cf10c6f71bca41ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to a task (blocking send) with acknowledgement.  <a href="#a288522d034824d53cf10c6f71bca41ea"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Sergio Johann Filho </dd></dl>
<dl class="section date"><dt>Date</dt><dd>April 2016</dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This source code is licensed under the GNU General Public License, Version 2. See the file 'doc/license/gpl-2.0.txt' for more details.</p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>NoC (Network-on-Chip) interconnect driver. This driver assumes a 16-bit channel width and a basic communication protocol between the cores and the network interface, provided by _ni_read(), _ni_write() and _ni_status() helper functions (defined on the architecture HAL). A 2D mesh NoC and a buffered (1 packet) network interface are assumed.</p>
<p>Packet format is as follows:</p>
<pre class="fragment"> 2 bytes   2 bytes   2 bytes   2 bytes   2 bytes   2 bytes   2 bytes   2 bytes       ....
--------------------------------------------------------------------------------------------------
|tgt_cpu  |payload  |src_cpu  |src_port |tgt_port |msg_size |seq      |channel  |  ... data ...  |
--------------------------------------------------------------------------------------------------
</pre><p>The platform should include the following macros:</p>
<p>NOC_INTERCONNECT intra-chip interconnection type CPU_ID a unique sequential number for each core NOC_WIDTH number of columns of the 2D mesh NOC_HEIGHT number of rows of the 2D mesh NOC_PACKET_SIZE packet size (in 16 bit flits) NOC_PACKET_SLOTS number of slots in the shared packet queue per core </p>
</div><h2>Function Documentation</h2>
<a class="anchor" id="a7cc950118783aff78ef381c30f411f31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hf_comm_create </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a communication queue for a task, using a port number as an alias. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the task id which will own the communication queue </td></tr>
    <tr><td class="paramname">port</td><td>is the receiving port for the task </td></tr>
    <tr><td class="paramname">packets</td><td>is the communication queue size, in packets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK when successful, ERR_INVALID_ID if no task matches the specified id, ERR_COMM_UNFEASIBLE if there is already a communication queue for the task, ERR_COMM_ERROR if there is already another task using the specified port and ERR_OUT_OF_MEMORY if the systems runs out of memory.</dd></dl>
<p>The queue created for the task will be used for the reception of data. Both <a class="el" href="noc_8c.html#a7ca8f6357767be7d8d8f31a1f68902a1" title="NoC driver: network interface interrupt service routine.">ni_isr()</a> and <a class="el" href="noc_8c.html#a27bdcde2185022f68eece2e0ed1c20ec" title="Receives a message from a task (blocking receive).">hf_recv()</a> routines will manage the queue, putting and pulling packets from the queue on demand. The communication subsystem is configured by the association of a task id to a receiving port (alias) and the definition of how many packet slots a task has on its queue. </p>

</div>
</div>
<a class="anchor" id="a2ca5bce1d7d281b5ca1ee007b170143b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hf_comm_destroy </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a communication queue, returning packets buffered on a task message queue to the shared pool of packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the task id which owns the communication queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK when successful, ERR_INVALID_ID if no task matches the specified id, ERR_COMM_ERROR if the queue could not be destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a73af25121fa7d699224d30913bb3cfa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t hf_cpuid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current cpu id number. </p>
<dl class="section return"><dt>Returns</dt><dd>the current cpu id, defined by the CPU_ID macro. </dd></dl>

</div>
</div>
<a class="anchor" id="ac100d0cfa54da4cf1c8ffda0947a7509"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t hf_ncores </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of processors in the system. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of cores, defined by the dimensions of the NoC mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="a27bdcde2185022f68eece2e0ed1c20ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hf_recv </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>source_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>source_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives a message from a task (blocking receive). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_cpu</td><td>is a pointer to a variable which will hold the source cpu </td></tr>
    <tr><td class="paramname">source_port</td><td>is a pointer to a variable which will hold the source port </td></tr>
    <tr><td class="paramname">buf</td><td>is a pointer to a buffer to hold the received message </td></tr>
    <tr><td class="paramname">size</td><td>a pointer to a variable which will hold the size (in bytes) of the received message </td></tr>
    <tr><td class="paramname">channel</td><td>is the selected message channel of this message (must be the same as in the sender)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK when successful, ERR_COMM_UNFEASIBLE when no message queue (comm) was created and ERR_SEQ_ERROR when received packets arrive out of order, so the message is corrupted.</dd></dl>
<p>A message is build from packets received on the <a class="el" href="noc_8c.html#a7ca8f6357767be7d8d8f31a1f68902a1" title="NoC driver: network interface interrupt service routine.">ni_isr()</a> routine. Packets are decoded and combined in a complete message, returning the message, its size and source identification to the calling task. The buffer where the message will be stored must be large enough or we will have a problem that may not be noticed before its too late. </p>

</div>
</div>
<a class="anchor" id="a264ff860d8ad312fea8d658b6c254f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hf_recvack </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>source_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>source_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives a message from a task (blocking receive) with acknowledgement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_cpu</td><td>is a pointer to a variable which will hold the source cpu </td></tr>
    <tr><td class="paramname">source_port</td><td>is a pointer to a variable which will hold the source port </td></tr>
    <tr><td class="paramname">buf</td><td>is a pointer to a buffer to hold the received message </td></tr>
    <tr><td class="paramname">size</td><td>a pointer to a variable which will hold the size (in bytes) of the received message </td></tr>
    <tr><td class="paramname">channel</td><td>is the selected message channel of this message (must be the same as in the sender)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK when successful, ERR_COMM_UNFEASIBLE when no message queue (comm) was created and ERR_SEQ_ERROR when received packets arrive out of order, so the message is corrupted.</dd></dl>
<p>A message is build from packets received on the <a class="el" href="noc_8c.html#a7ca8f6357767be7d8d8f31a1f68902a1" title="NoC driver: network interface interrupt service routine.">ni_isr()</a> routine. Packets are decoded and combined in a complete message, returning the message, its size and source identification to the calling task. The buffer where the message will be stored must be large enough or we will have a problem that may not be noticed before its too late. After the reception of the whole message is completed, an acknowledgement is sent to the sender task. This works as a flow control mechanism, avoiding buffer/queue overflows common to the raw protocol. Message channel 65535 will be used for the flow control mechanism. </p>

</div>
</div>
<a class="anchor" id="ae7c110f06bc1e123f03b2d52d8b6d70f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hf_send </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>target_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>target_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to a task (blocking send). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_cpu</td><td>is the target processor </td></tr>
    <tr><td class="paramname">target_port</td><td>is the target task port </td></tr>
    <tr><td class="paramname">buf</td><td>is a pointer to a buffer that holds the message </td></tr>
    <tr><td class="paramname">size</td><td>is the size (in bytes) of the message </td></tr>
    <tr><td class="paramname">channel</td><td>is the selected message channel of this message (must be the same as in the receiver)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK</dd></dl>
<p>A message is broken into packets containing a header and part of the message as the payload. The packets are injected, one by one, in the network through the network interface. </p>

</div>
</div>
<a class="anchor" id="a288522d034824d53cf10c6f71bca41ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hf_sendack </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>target_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>target_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to a task (blocking send) with acknowledgement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_cpu</td><td>is the target processor </td></tr>
    <tr><td class="paramname">target_port</td><td>is the target task port </td></tr>
    <tr><td class="paramname">buf</td><td>is a pointer to a buffer that holds the message </td></tr>
    <tr><td class="paramname">size</td><td>is the size (in bytes) of the message </td></tr>
    <tr><td class="paramname">channel</td><td>is the selected message channel of this message (must be the same as in the receiver) </td></tr>
    <tr><td class="paramname">timeout</td><td>is the time (in ms) that the sender will wait for a reception acknowledgement</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK</dd></dl>
<p>A message is broken into packets containing a header and part of the message as the payload. The packets are injected, one by one, in the network through the network interface. After that, the sender will wait for an acknowledgement from the receiver. This works as a flow control mechanism, avoiding buffer/queue overflows common to the raw protocol. Message channel 65535 will be used for the flow control mechanism. </p>

</div>
</div>
<a class="anchor" id="acb44cf0de3a986b823c53d881bff9568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ni_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NoC driver: initializes the network interface. </p>
<p>A queue for the packet driver is initialized with NOC_PACKET_SLOTS capacity (in packets). The queue is populated with empty packets (pointers to dinamically allocated memory areas) which will be used (shared) among all tasks for the reception of data. The hardware is reset and the NoC interrupt handler is registered. This routine is called during the system boot-up and is dependent on the architecture implementation. </p>

</div>
</div>
<a class="anchor" id="a7ca8f6357767be7d8d8f31a1f68902a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ni_isr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NoC driver: network interface interrupt service routine. </p>
<p>This routine is called by the second level of interrupt handling. An interrupt from the network interface means a full packet has arrived. The packet header is decoded and the target port is identified. A reference to an empty packet is removed from the pool of buffers (packets), the contents of the empty packet are filled with flits from the hardware queue and the reference is put on the target task (associated to a port) queue of packets. There is one queue per task of configurable size. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 23 2017 15:06:47 for HellfireOS v2.0 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
