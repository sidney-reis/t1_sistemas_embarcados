\hypertarget{condvar_8c}{\section{sys/sync/condvar.c File Reference}
\label{condvar_8c}\index{sys/sync/condvar.\-c@{sys/sync/condvar.\-c}}
}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int32\-\_\-t \hyperlink{condvar_8c_a6f0858342a87feaa65201dcd20b2686d}{hf\-\_\-condinit} (\hyperlink{condvar_8h_aa30db9b03ec1456e8e3016d92f7a321b}{cond\-\_\-t} $\ast$c)
\begin{DoxyCompactList}\small\item\em Initializes a condition variable. \end{DoxyCompactList}\item 
int32\-\_\-t \hyperlink{condvar_8c_a0085b7d8162e3195b6c5a021f811ce17}{hf\-\_\-conddestroy} (\hyperlink{condvar_8h_aa30db9b03ec1456e8e3016d92f7a321b}{cond\-\_\-t} $\ast$c)
\begin{DoxyCompactList}\small\item\em Destroys a condition variable. \end{DoxyCompactList}\item 
void \hyperlink{condvar_8c_a2500f2dc6bebbd3b2c106c2062ad9cff}{hf\-\_\-condwait} (\hyperlink{condvar_8h_aa30db9b03ec1456e8e3016d92f7a321b}{cond\-\_\-t} $\ast$c, \hyperlink{mutex_8h_a5d47ad3a25c2df1eecad005e0649a431}{mutex\-\_\-t} $\ast$m)
\begin{DoxyCompactList}\small\item\em Wait on a condition variable. \end{DoxyCompactList}\item 
void \hyperlink{condvar_8c_a1b4c91e74810a728df751b5b9164b628}{hf\-\_\-condsignal} (\hyperlink{condvar_8h_aa30db9b03ec1456e8e3016d92f7a321b}{cond\-\_\-t} $\ast$c)
\begin{DoxyCompactList}\small\item\em Signal a condition variable. \end{DoxyCompactList}\item 
void \hyperlink{condvar_8c_ad9451e9cd837efdee55102545c130f36}{hf\-\_\-condbroadcast} (\hyperlink{condvar_8h_aa30db9b03ec1456e8e3016d92f7a321b}{cond\-\_\-t} $\ast$c)
\begin{DoxyCompactList}\small\item\em Signal (broadcast) a condition variable. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyAuthor}{Author}
Sergio Johann Filho 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
May 2016
\end{DoxyDate}
\hypertarget{semaphore_8c_LICENSE}{}\subsection{L\-I\-C\-E\-N\-S\-E}\label{semaphore_8c_LICENSE}
This source code is licensed under the G\-N\-U General Public License, Version 2. See the file 'doc/license/gpl-\/2.\-0.\-txt' for more details.\hypertarget{semaphore_8c_DESCRIPTION}{}\subsection{D\-E\-S\-C\-R\-I\-P\-T\-I\-O\-N}\label{semaphore_8c_DESCRIPTION}
Condition variable synchronization primitives. 

\subsection{Function Documentation}
\hypertarget{condvar_8c_ad9451e9cd837efdee55102545c130f36}{\index{condvar.\-c@{condvar.\-c}!hf\-\_\-condbroadcast@{hf\-\_\-condbroadcast}}
\index{hf\-\_\-condbroadcast@{hf\-\_\-condbroadcast}!condvar.c@{condvar.\-c}}
\subsubsection[{hf\-\_\-condbroadcast}]{\setlength{\rightskip}{0pt plus 5cm}void hf\-\_\-condbroadcast (
\begin{DoxyParamCaption}
\item[{{\bf cond\-\_\-t} $\ast$}]{c}
\end{DoxyParamCaption}
)}}\label{condvar_8c_ad9451e9cd837efdee55102545c130f36}


Signal (broadcast) a condition variable. 


\begin{DoxyParams}{Parameters}
{\em c} & is a pointer to a condition variable.\\
\hline
\end{DoxyParams}
Implements the condition signal broadcast operation for all waiting tasks. The call unblocks and removes all tasks from the waiting queue. If no tasks are waiting for the condition, the signal is lost. \hypertarget{condvar_8c_a0085b7d8162e3195b6c5a021f811ce17}{\index{condvar.\-c@{condvar.\-c}!hf\-\_\-conddestroy@{hf\-\_\-conddestroy}}
\index{hf\-\_\-conddestroy@{hf\-\_\-conddestroy}!condvar.c@{condvar.\-c}}
\subsubsection[{hf\-\_\-conddestroy}]{\setlength{\rightskip}{0pt plus 5cm}int32\-\_\-t hf\-\_\-conddestroy (
\begin{DoxyParamCaption}
\item[{{\bf cond\-\_\-t} $\ast$}]{c}
\end{DoxyParamCaption}
)}}\label{condvar_8c_a0085b7d8162e3195b6c5a021f811ce17}


Destroys a condition variable. 


\begin{DoxyParams}{Parameters}
{\em c} & is a pointer to a condition variable.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\-R\-R\-\_\-\-O\-K on success and E\-R\-R\-\_\-\-E\-R\-R\-O\-R if the condition variable could not be removed from memory. 
\end{DoxyReturn}
\hypertarget{condvar_8c_a6f0858342a87feaa65201dcd20b2686d}{\index{condvar.\-c@{condvar.\-c}!hf\-\_\-condinit@{hf\-\_\-condinit}}
\index{hf\-\_\-condinit@{hf\-\_\-condinit}!condvar.c@{condvar.\-c}}
\subsubsection[{hf\-\_\-condinit}]{\setlength{\rightskip}{0pt plus 5cm}int32\-\_\-t hf\-\_\-condinit (
\begin{DoxyParamCaption}
\item[{{\bf cond\-\_\-t} $\ast$}]{c}
\end{DoxyParamCaption}
)}}\label{condvar_8c_a6f0858342a87feaa65201dcd20b2686d}


Initializes a condition variable. 


\begin{DoxyParams}{Parameters}
{\em c} & is a pointer to a condition variable.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\-R\-R\-\_\-\-O\-K on success and E\-R\-R\-\_\-\-E\-R\-R\-O\-R if the condition variable could not be allocated in memory. 
\end{DoxyReturn}
\hypertarget{condvar_8c_a1b4c91e74810a728df751b5b9164b628}{\index{condvar.\-c@{condvar.\-c}!hf\-\_\-condsignal@{hf\-\_\-condsignal}}
\index{hf\-\_\-condsignal@{hf\-\_\-condsignal}!condvar.c@{condvar.\-c}}
\subsubsection[{hf\-\_\-condsignal}]{\setlength{\rightskip}{0pt plus 5cm}void hf\-\_\-condsignal (
\begin{DoxyParamCaption}
\item[{{\bf cond\-\_\-t} $\ast$}]{c}
\end{DoxyParamCaption}
)}}\label{condvar_8c_a1b4c91e74810a728df751b5b9164b628}


Signal a condition variable. 


\begin{DoxyParams}{Parameters}
{\em c} & is a pointer to a condition variable.\\
\hline
\end{DoxyParams}
Implements the condition signal operation for one waiting task. The call removes a task from the waiting queue and unblocks it. If no tasks are waiting for the condition, the signal is lost. \hypertarget{condvar_8c_a2500f2dc6bebbd3b2c106c2062ad9cff}{\index{condvar.\-c@{condvar.\-c}!hf\-\_\-condwait@{hf\-\_\-condwait}}
\index{hf\-\_\-condwait@{hf\-\_\-condwait}!condvar.c@{condvar.\-c}}
\subsubsection[{hf\-\_\-condwait}]{\setlength{\rightskip}{0pt plus 5cm}void hf\-\_\-condwait (
\begin{DoxyParamCaption}
\item[{{\bf cond\-\_\-t} $\ast$}]{c, }
\item[{{\bf mutex\-\_\-t} $\ast$}]{m}
\end{DoxyParamCaption}
)}}\label{condvar_8c_a2500f2dc6bebbd3b2c106c2062ad9cff}


Wait on a condition variable. 


\begin{DoxyParams}{Parameters}
{\em c} & is a pointer to a condition variable. \\
\hline
{\em m} & is a pointer to a mutex.\\
\hline
\end{DoxyParams}
Implements the atomic condition wait operation. The call should always be invoked with the mutex locked. The current task is put in a queue on the condition variable, its state is set to blocked and unlocks the mutex atomically, then yields the processor. When woke up (by a signalling task), the task locks the mutex and returns. 